//Subhankar bokachoda
//Rohon er bou amar raater partner

#include <bits/stdc++.h>
 
using namespace std;
typedef long long ll;
typedef vector<int > vi;
typedef vector<vector<int>> vvi;
typedef vector<long long> vll;
typedef pair<int,int> pii;
typedef pair<long long,long long > pll;
typedef vector<pair<ll,ll>> vpll;
#define fr(i,n,a) for(long long i=a; i<n; i++)
#define ufr(i,n,a) for(long long i=n-1; i>=a; i--)
#define vin(v) int n; cin>>n;vector<int>v; for(int i=0;i<n;i++){int x; cin>>x; v.push_back(x);}  
#define ain(a) int n; cin>>n; ll a[]; for(int i=0;i<n;i++){cin>>a[i];}
#define vout(v) for(auto &e:v){cout<<e<<" ";} cout<<endl;
#define mout(mp) for(auto &e:mp){cout<<e.first<<" "<<e.second;} cout<<endl;
#define mvout(mp) for(auto &e:mp){cout<<e.F<<"--------->\n";for(long long i =0 ; i<(e.second).size();i++){cout<<(e.second)[i]<<" ";}cout<<"\n";} cout<<endl;
#define Sort(a) sort(a.begin(),a.end())
#define Sorta(a,n) sort(a,a+n)
#define pb push_back 
#define F first
#define S second 
const ll M = 1000000000+7;
 
 
 

ll test =0;
 

 
 
    
 
void solve(){

}
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int t=1;
    //cin>>t;
    while(t--){
        test++;
        solve();
    }
 
} 
/*
greedy --
bit --
bit aljebra -- 
binary serarch -- 
aljebra -- 
binary search on bits ---- 
process to directly take out the ans --- 
is all the cases possible or the first 3 4 values are only possible(remainder questions)---- mistake have been made here(note)
dp---- 
dp to direcly take tout the ans--- 
making a part constat and then dp on remaining part---
putting values (1 0 2) then finding the ans--- 
factors -- 
prime factors-
prefix sum to directly get the ans --- 
two pointer sliding windows --- 
when ever thinging is complex try to refresh it in a more simple way-- 
sort----
(+1 -1 trick along with prefix sum)----
write all possibilities--- 
two pinter--
sliding window--- 
modolulo divide logic(gcd logic)

*/ 
